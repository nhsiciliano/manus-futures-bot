#!/usr/bin/env python3
"""
Bot de Trading Autom√°tico para Futuros de Criptomonedas - Versi√≥n Robusta
Estrategia: Confluencia de indicadores en m√∫ltiples temporalidades
Autor: Manus AI
"""

import asyncio
import time
import signal
import sys
import traceback
from typing import Dict, List
import logging

from binance_client import BinanceAPIClient
from trading_strategy import TradingStrategy
from risk_manager import RiskManager
from position_manager import PositionManager
from logger import TradingLogger
import config

class RobustTradingBot:
    """Bot principal de trading autom√°tico con manejo robusto de errores"""
    
    def __init__(self):
        """Inicializar el bot de trading"""
        self.running = False
        self.logger = None
        self.binance_client = None
        self.trading_strategy = None
        self.risk_manager = None
        self.position_manager = None
        self.cycle_count = 0
        self.last_successful_cycle = None
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Manejar se√±ales de cierre"""
        print("\nSe√±al de cierre recibida. Cerrando bot de forma segura...")
        self.running = False
    
    async def initialize_components(self) -> bool:
        """Inicializar todos los componentes del bot"""
        try:
            print("üîß Inicializando componentes del bot...")
            self.logger = TradingLogger()
            self.logger.log_bot_status("STARTING", "Inicializando componentes del bot")
            
            print("üì° Conectando a Binance API...")
            self.binance_client = BinanceAPIClient()
            
            if not self.binance_client.test_connection():
                self.logger.log_error("No se pudo establecer conexi√≥n con Binance")
                print("‚ùå Error: No se pudo conectar a Binance API")
                return False
            print("‚úÖ Conexi√≥n a Binance establecida")

            print("üîå Iniciando stream de datos de mercado (Websocket)...")
            self.binance_client.start_kline_stream()
            
            print("‚è≥ Esperando la llegada de datos iniciales del stream...")
            await asyncio.sleep(10) # Dar tiempo a que el websocket se conecte y reciba datos

            print("üìà Cargando datos hist√≥ricos iniciales para el an√°lisis...")
            await self._populate_initial_klines()

            print("üìä Inicializando estrategia de trading...")
            self.trading_strategy = TradingStrategy(self.binance_client)
            
            print("üõ°Ô∏è Inicializando gestor de riesgos...")
            self.risk_manager = RiskManager(self.binance_client)
            
            print("üìà Inicializando gestor de posiciones...")
            self.position_manager = PositionManager()
            self.position_manager.load_positions_from_file()
            
            self.logger.log_bot_status("INITIALIZED", "Todos los componentes inicializados correctamente")
            print("‚úÖ Todos los componentes inicializados correctamente")
            return True
            
        except Exception as e:
            error_msg = f"Error al inicializar componentes: {str(e)}"
            if self.logger:
                self.logger.log_error(error_msg, e)
            else:
                print(f"‚ùå {error_msg}")
                print(f"Traceback: {traceback.format_exc()}")
            return False

    async def _populate_initial_klines(self):
        """Carga los datos hist√≥ricos de klines al inicio"""
        for symbol in config.SYMBOLS:
            for interval in [config.INTERVAL_15M, config.INTERVAL_4H]:
                try:
                    klines = self.binance_client.get_klines(symbol, interval, 500)
                    if not klines.empty:
                        stream_name = f"{symbol.lower()}@kline_{interval}"
                        self.binance_client.kline_streamer.klines[stream_name] = klines
                        self.logger.info(f"Cargados {len(klines)} klines hist√≥ricos para {symbol} ({interval})")
                    else:
                        self.logger.warning(f"No se pudieron cargar klines hist√≥ricos para {symbol} ({interval})")
                    await asyncio.sleep(0.5) # Peque√±a pausa para no sobrecargar la API
                except Exception as e:
                    self.logger.error(f"Error cargando klines hist√≥ricos para {symbol} ({interval}): {e}")

    async def analyze_markets_safe(self) -> List[Dict]:
        """Analizar todos los mercados configurados"""
        analysis_results = []
        try:
            self.logger.info(f"üîç Iniciando an√°lisis de mercados (Ciclo #{self.cycle_count})")
            
            for symbol in config.SYMBOLS:
                try:
                    self.logger.debug(f"Analizando {symbol}")
                    analysis = self.trading_strategy.analyze_symbol(symbol)
                    if analysis and analysis.get('signal') != 'HOLD':
                        analysis_results.append(analysis)
                        self.logger.info(f"üìä {symbol}: {analysis['signal']} (Confianza: {analysis['confidence']:.2f})")
                    elif analysis:
                         self.logger.info(f"üìä {symbol}: {analysis['signal']} (Confianza: {analysis['confidence']:.2f})")
                    else:
                        self.logger.warning(f"No se pudo obtener an√°lisis para {symbol}")
                        
                except Exception as e:
                    self.logger.log_error(f"Error al analizar {symbol}", e)
                    continue
            
            self.logger.info(f"‚úÖ An√°lisis completado: {len(analysis_results)} s√≠mbolos procesados")
            return analysis_results
            
        except Exception as e:
            self.logger.log_error("Error cr√≠tico en an√°lisis de mercados", e)
            return []
    
    async def execute_trades_safe(self, analysis_results: List[Dict]) -> None:
        """Ejecutar operaciones basadas en los an√°lisis"""
        try:
            high_confidence_signals = [a for a in analysis_results if a['confidence'] >= config.CONFIDENCE_THRESHOLD and a['signal'] != 'HOLD']
            
            if not high_confidence_signals:
                self.logger.info("üìä No hay se√±ales de alta confianza para operar en este ciclo")
                return

            self.logger.info(f"üéØ Procesando {len(high_confidence_signals)} se√±ales de trading con alta confianza")
            
            for analysis in high_confidence_signals:
                try:
                    symbol = analysis['symbol']
                    signal = analysis['signal']
                    
                    if not self.risk_manager.can_open_new_position():
                        self.logger.warning("‚ö†Ô∏è No se pueden abrir m√°s posiciones (l√≠mite alcanzado)")
                        break
                    
                    if self.position_manager.get_position(symbol):
                        self.logger.warning(f"‚ö†Ô∏è Ya existe posici√≥n para {symbol}")
                        continue
                    
                    entry_price = analysis['current_price']
                    stop_loss = self.risk_manager.calculate_stop_loss(symbol, signal, entry_price)
                    take_profit = self.risk_manager.calculate_take_profit(entry_price, stop_loss, signal)
                    balance = self.binance_client.get_account_balance()
                    position_size_usdt = self.risk_manager.calculate_position_size(balance, entry_price, stop_loss)
                    
                    if not self.risk_manager.validate_trade_parameters(symbol, signal, entry_price, stop_loss, take_profit, position_size_usdt):
                        self.logger.warning(f"‚ö†Ô∏è Par√°metros de operaci√≥n inv√°lidos para {symbol}")
                        continue

                    self.logger.info(f"üöÄ Ejecutando se√±al {signal} para {symbol} con tama√±o {position_size_usdt:.2f} USDT")
                    # Aqu√≠ ir√≠a la l√≥gica para ejecutar la orden
                    
                except Exception as e:
                    self.logger.log_error(f"Error al ejecutar operaci√≥n para {analysis.get('symbol', 'UNKNOWN')}", e)
                    
        except Exception as e:
            self.logger.log_error("Error cr√≠tico en ejecuci√≥n de trades", e)
    
    async def monitor_positions_safe(self) -> None:
        """Monitorear posiciones existentes"""
        # L√≥gica de monitoreo
        pass
    
    async def run_cycle_safe(self) -> bool:
        """Ejecutar un ciclo completo del bot"""
        try:
            self.cycle_count += 1
            cycle_start = time.time()
            self.logger.debug(f"üîÑ Iniciando ciclo #{self.cycle_count}")
            
            analysis_results = await self.analyze_markets_safe()
            await self.execute_trades_safe(analysis_results)
            await self.monitor_positions_safe()
            
            cycle_duration = time.time() - cycle_start
            self.last_successful_cycle = time.time()
            self.logger.info(f"‚úÖ Ciclo #{self.cycle_count} completado en {cycle_duration:.2f}s")
            return True
            
        except Exception as e:
            self.logger.log_error(f"Error en ciclo #{self.cycle_count}", e)
            return False
    
    async def run(self) -> None:
        """Ejecutar el bucle principal del bot"""
        try:
            self.running = True
            self.logger.log_bot_status("RUNNING", "Bot iniciado correctamente")
            print("ü§ñ Bot iniciado - Operando 24/7")
            print(f"üìä Monitoreando: {', '.join(config.SYMBOLS)}")
            print(f"‚è±Ô∏è Intervalo: {config.BOT_RUN_INTERVAL} segundos")
            
            while self.running:
                await self.run_cycle_safe()
                self.logger.debug(f"‚è≥ Esperando {config.BOT_RUN_INTERVAL} segundos...")
                await asyncio.sleep(config.BOT_RUN_INTERVAL)
            
        except asyncio.CancelledError:
            self.logger.info("üõë Bot cancelado")
        except Exception as e:
            self.logger.log_error("Error cr√≠tico en el bucle principal", e)
        finally:
            await self.shutdown()
    
    async def shutdown(self) -> None:
        """Cierre seguro del bot"""
        try:
            self.logger.log_bot_status("SHUTDOWN", "Iniciando cierre seguro")
            print("üõë Cerrando bot de forma segura...")
            
            if self.binance_client:
                self.binance_client.stop_kline_stream()
                print("üîå Stream de datos detenido")

            if self.position_manager:
                self.position_manager.save_positions_to_file()
                print("üíæ Posiciones guardadas")
            
            self.logger.log_bot_status("SHUTDOWN", "Bot cerrado correctamente")
            print("‚úÖ Bot cerrado correctamente")
            
        except Exception as e:
            if self.logger:
                self.logger.log_error("Error durante el cierre", e)
            print(f"‚ùå Error durante el cierre: {e}")

async def main():
    """Funci√≥n principal con reinicio autom√°tico"""
    print("=" * 60)
    print("ü§ñ MANUS TRADING BOT - VERSI√ìN ROBUSTA")
    print("=" * 60)
    
    bot = RobustTradingBot()
    try:
        if await bot.initialize_components():
            print("‚úÖ Bot inicializado correctamente")
            print("üîÑ Presiona Ctrl+C para detener")
            await bot.run()
    except KeyboardInterrupt:
        print("\nüõë Bot detenido por el usuario")
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        print(f"üìä Traceback: {traceback.format_exc()}")
    finally:
        await bot.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
